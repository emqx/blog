## 保留消息

服务端收到 Retain 标志为 1 的 PUBLISH 报文时，会将该报文视为保留消息，除了被正常转发以外，保留消息会被存储在服务端，每个主题下只能存在一份保留消息，因此如果已经存在相同主题的保留消息，则该保留消息被替换。

当客户端建立订阅时，如果服务端存在主题匹配的保留消息，则这些保留消息将被立即发送给该客户端。借助保留消息，新的订阅者能够立即获取最近的状态，而不需要等待无法预期的时间，这在很多场景下非常重要的。

保留消息虽然存储在服务端中，但它并不属于会话的一部分。也就是说，即便发布这个保留消息的会话终结，保留消息也不会被删除。删除保留消息只有两种方式：

1. 客户端往某个主题发送一个 Payload 为空的保留消息，服务端就会删除这个主题下的保留消息。
2. 如果包含保留消息的 PUBLISH 报文设置了消息过期间隔属性，那么保留消息在服务端存储超过过期时间后就会被删除。

## 消息过期间隔

PUBLISH 报文可以设置消息过期间隔这一属性，消息过期间隔是一个四字节的整数，表示应用消息的生命周期，单位是秒。

如果 PUBLISH 报文不设置消息过期间隔，那么应用消息不会过期。

如果 PUBLISH 报文设置了消息过期间隔，并且消息过期将已经过期，服务端还没开始向匹配的订阅者交付该消息，那么服务端必须删除该消息。

## EMQ X MQTT 服务器的保留消息

[EMQ X MQTT Broker](https://www.emqx.com/en) 的保留消息功能是由 `emqx_retainer` 插件实现，该插件默认开启，通过修改 `emqx_retainer` 插件的配置，可以调整 EMQ X Broker 储存保留消息的位置，限制接收保留消息数量和 Payload 最大长度，以及调整保留消息的过期时间。

`emqx_retainer` 插件默认开启，插件的配置路径为 `etc/plugins/emqx_retainer.conf`。

+ retainer.storage_type

  保留消息的储存位置，EMQ X Broker 可以选择将保留消息仅储存在内存中，仅储存在硬盘中，或是同时储存在内存和硬盘中，可以由用户的业务特点灵活决定。

  例如，想要收集电表读数的用户可能会决定使用 QoS 等级 1 的消息，因为他们不能接受数据在网络传输途中丢失，但是，他们可能认为客户端和服务端的数据可以存储在内存（易失性存储器）中，因为电力供应系统是非常可靠的，不会有太大的数据丢失风险。

  与之相反，停车计费支付应用的提供商可能决定任何情况下都不能让数据支付消息丢失，因此他们要求在通过网络传输之前将所有的数据写入到硬盘中（非易失性存储器）。

+ retainer.max_retained_messages、retainer.max_payload_size

  `retainer.max_retained_messages`  规定了 EMQ X Broker 可以储存的保留消息的最大数量，0 表示没有限制。保留消息数量超出最大值限制后，可以替换已存在的保留消息，但不能为新的主题储存保留消息。

  `retainer.max_payload_size`  规定了 EMQ X Broker 可以接收的保留消息的最大 Payload 值。Payload 大小超出最大值后 EMQ Ｘ 消息服务器会把收到的保留消息作为普通消息处理，不再储存此消息。

  这两项配置规定了 EMQ X Broker 可以接收与储存的保留消息的上限，保证了 EMQ X Broker 不会占用过多的资源来储存和处理保留消息。

+ retainer.expiry_interval

  保留消息的过期时间，0 表示永不过期。如果 PUBLISH 报文中设置了消息过期间隔，那么以 PUBLISH 报文中的消息过期间隔为准。

  当保留消息的过期后，EMQ X Broker 会删除掉此消息。
