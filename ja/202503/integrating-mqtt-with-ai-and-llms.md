[本シリーズの最初の記事](https://www.emqx.com/ja/blog/why-and-how-mqtt-is-used-in-ai-llm-applications)で、MQTTがIoTデータとAI・LLMアプリケーションをどのようにつなぐかを概観しました。ここでは、実際の実装面に焦点を当て、特にセキュリティ・スケーラビリティ・パフォーマンスといった重要な検討事項、他のプロトコルとの比較、導入時の課題、そして今後の可能性について掘り下げていきます。

## セキュリティ、スケーラビリティ、パフォーマンスに関する考慮事項

MQTTには多くの利点がありますが、AI推論やLLMの用途で大規模に運用するには、セキュリティ・スケーラビリティ・パフォーマンスに十分な配慮が必要です。

### セキュリティに関する考慮事項

[MQTT](https://www.emqx.com/ja/blog/the-easiest-guide-to-getting-started-with-mqtt) は軽量なメッセージングを念頭に設計されていますが、ミッションクリティカルなAIアプリケーション（物理デバイスの制御など）ではセキュリティが最優先となります。主なポイントは以下のとおりです。

- **認証と認可（Authentication & Authorization）**
  クライアント（デバイスやAIサービス）が正当な権限を持ち、特定のトピックにのみ接続・送受信できるようにする必要があります。MQTTプロトコル自体には認証方式が定義されていませんが、ブローカー側で実装されます。一般的には[ユーザー名／パスワード](https://www.emqx.com/ja/blog/securing-mqtt-with-username-and-password-authentication)、[TLSクライアント証明書](https://www.emqx.com/ja/blog/two-way-tls-ssl-with-emqx-cloud)、あるいは[JWTトークン](https://www.emqx.com/ja/blog/a-deep-dive-into-token-based-authentication-and-oauth-2-0-in-mqtt)が使われます。**ACL（Access Control List）**を細かく設定し、たとえばサーモスタットデバイスは `home/thermostat/{sensor-id}/temp` のみで発行し、他の無関係なトピックは購読できないようにします。このような厳密な認証・認可により、悪意ある第三者の侵入や不正なメッセージ送信を防ぎます。
- **暗号化**
  MQTTはTLS上（HTTPSと同様）で動作させることが可能であり、本番環境の多くでは必須とも言えます。通信経路を暗号化することで、盗聴や改ざんを防止します。多くのMQTTブローカーでは、ポート8883でTLSを使用します。さらに厳格な要件のある場合、ブローカーのコンプロマイズを想定してメッセージペイロードをアプリケーションレベルで暗号化（エンドツーエンド暗号化）することもあります。
- **データの完全性と検証**
  AIシステムが受け取るデータを信頼できるようにするには、MQTTのQoS 1または2を用いてメッセージを確実（少なくとも1回、または重複なしで正確に1回）届ける設定が必要です。ネットワーク障害によるメッセージのロスや重複を防げるという点で、AIに正しい入力を提供できます。ただし、データが正しくフォーマットされ、想定範囲内であるかどうかを検証することも重要です（マルウェア的な入力によってAIの動作が不安定になる恐れがあるため）。[EMQX Smart Data Hub](https://www.emqx.com/en/blog/introducing-emqx-platform-smart-data-hub) などでは、**スキーマレジストリ**や**スキーマバリデーション**機能が利用でき、データの整合性をチェックできます。
- **ブローカーのセキュリティ**
  [MQTTブローカー](https://www.emqx.com/ja/blog/the-ultimate-guide-to-mqtt-broker-comparison) はシステムの中核となる存在であり、堅牢なセキュリティ設定と監視が求められます。強固な認証情報の設定、脆弱性修正のためのアップデート、ファイアウォールやVPNによるネットワークセグメンテーションなどが有効です。ログや監視を有効にして、不審なクライアント（大量のトピックを購読しようとするなど）を検知しましょう。また、ブルートフォースやDDoSを防ぐためのレート制限も検討します。
- **LLM特有のセキュリティ**
  LLMがMQTT経由でプロンプトや応答をやり取りする場合、機密情報が含まれる可能性があるため、トピックを適切に保護する必要があります。また、**プロンプトインジェクション**のリスクにも注意が必要です。攻撃者がLLMサービスの購読トピックに細工したプロンプトをパブリッシュし、不適切な動作を誘導する恐れがあります。入力バリデーションやLLMガードレールの実装が望ましいケースです。

まとめると、MQTTのセキュリティは一般的なITセキュリティの原則（機密性・完全性・可用性）をIoT向けに適用したものとなります。

> *「MQTTセキュリティは、デバイス間でやり取りされるデータの機密性・完全性・可用性を確保する上で極めて重要です。」*
> — [7 Essential Things to Know about MQTT Security 2023](https://www.emqx.com/ja/blog/essential-things-to-know-about-mqtt-security)

TLSを使った暗号化やトピックレベルの認可などを正しく実装すれば、自動車やヘルスケアのように機密性が求められる用途でも高いセキュリティを保てます。

### スケーラビリティに関する考慮事項

特にIoTにおけるAIアプリケーションでは、数千～数百万台のデバイスからデータを扱うこともあります。MQTTブローカーや関連インフラをスケールできるように設計しなければなりません。

- **ブローカーのスループットとクラスタリング**
  単一ブローカーでも膨大なクライアント接続数とメッセージ転送を捌く例がありますが、より大規模な運用ではクラスタリングが一般的です。複数のブローカーノードで負荷を分散し、クライアントのセッション状態を共有する仕組みを取り、どのノードに接続してもサブスクライバーがデータを受け取れるようにします。たとえば[EMQXでは、**1億台のデバイス**を一つのクラスタで安定接続した実績](https://www.emqx.com/en/blog/reaching-100m-mqtt-connections-with-emqx-5-0)もあります。IoT-AIシステムの需要増に伴いノードを追加し、リニアにスケールできるのが利点です。
- **トピックの階層構造とパーティショニング**
  MQTTのトピック設計はスケーラビリティに影響します。膨大なデバイスが1つのトピックに集中するとボトルネックになりやすいため、デバイスIDや地域ごとにトピックを分割し負荷を分散するとよいでしょう。ブローカーによってはKafkaのようなパーティショニング機能を持つものもありますが、多くの場合はトピックの階層構造や複数ブローカーの活用でスケーラビリティを確保します。また、AI側のサブスクライバーが過度に広範なワイルドカードを使い、一括で巨大なトピックを購読しすぎないように設計することも重要です。
- **過負荷、バックプレッシャー、オフライン時の対応**
  AI推論を行うサービスが大量のメッセージを捌ききれない場合、キューの滞留やメモリ不足などが発生するリスクがあります。MQTTのQoSは基本的にデバイス～ブローカー間のメッセージ配信を保証しますが、その先のAI処理が間に合わなければ、未処理メッセージが蓄積してしまうこともあります。また、多数のデバイスが一斉オフラインになった後、再接続する“サージ”が発生した場合には、スパイク的な負荷でAIサービスがパンクする可能性があります。こうした事態を防ぐためには、バッファリングやストリーム処理基盤（Apache FlinkやKafka Streamsなど）を活用し、負荷を平準化したり、AIサービス側でのバックプレッシャーやアドミッション制御を導入したりといった対応が必要です。
- **ビッグデータシステムへのブリッジ**
  多くのIoTシステムではMQTTをデバイスとのリアルタイム通信に使い、そこからクラウドデータベースやApache Kafkaなどのデータパイプラインへ繋いでAIのトレーニングや長期分析を行う構成が一般的です。MQTTとKafkaを組み合わせる例は多く、MQTTがデバイス側の接続をカバーし、Kafkaがスケーラブルなデータ蓄積とストリーミングを担う形です。MQTTブローカーやコネクタでKafkaへのブリッジを実装して、ビッグデータ処理へスムーズに連携できます。
- **エッジとクラウドの分散配置**
  非常に多くのデバイスを扱う場合は、**階層型のMQTT配置**が効果的です。エッジブローカー（工場や車両単位など）でローカルデータを収集し、一次的なAI推論やフィルタリングを行い、要点のみをクラウドMQTTブローカーに転送する方法です。これによりネットワーク帯域の削減やローカルでの独立稼働が可能になります。自動車業界では車載内のサブシステムをつなぐ小規模ブローカーと、クラウド側の大規模ブローカーを橋渡しするケースが一般的です。

![100 million connections](https://assets.emqx.com/images/9e455a23d7148e0a2a25e41e5e161432.png)

### パフォーマンスに関する考慮事項

MQTTベースのAIシステムのパフォーマンスは、**レイテンシ・スループット・リソース使用量**の観点で評価できます。

- **レイテンシ**
  MQTTは初回のTCP接続とハンドシェイク後、メッセージのオーバーヘッドが非常に少なく、数十ミリ秒程度のオーダーでデバイス→ブローカー→サブスクライバーへの配信が可能です（ネットワーク状況による）。HTTPのように毎回のリクエストでTCP/TLSハンドシェイクやヘッダが発生するのに比べると、はるかに高速です。AI推論の場合、推論そのものに要する時間（LLMの場合は数秒かかるケースも）が大きいかもしれませんが、通信の遅延が少ないことでリアルタイム性は高まります。大規模負荷時にもブローカーがボトルネックにならないように、クラスタリングやロードバランシングが重要です。
- **スループットとメッセージサイズ**
  MQTTは小型メッセージを大量に送信する用途に最適化されています。大きなペイロード（画像や大容量プロンプトなど）を送りたい場合は注意が必要です。MQTT 5では最大256MB程度までサポートしていますが、多くのブローカーでより小さい上限（例：1MB）が設定されていることもあります。大型データを分割送信したり、クラウドストレージへアップロードしてMQTTでURLを共有するといった工夫が必要な場合があります。LLMのテキストプロンプトや応答程度であれば通常は問題ありませんが、モデルチェックポイントのような膨大なファイルを自動車などに送る際は、別の配信手段を使うことが多いです。スループットに関しては、現代のブローカーは1秒あたり数十万のメッセージ処理をこなすものもありますが、10,000件／秒のセンサー読み取りなどをサブスクライブするAIが本当に捌けるかどうかは、サブスクライバー側の性能も含めて要検証です。不要な細かいデータをまとめて集約（エッジ分析）することで、メッセージ数を大幅に削減する方法もよく使われます。
- **QoSのトレードオフ**
  MQTTのQoS 0は最も高速（確認応答なし）ですが、メッセージが稀にドロップする可能性があります。QoS 1や2は高信頼ですが、確認応答のやり取りでわずかなオーバーヘッドが発生します。緊急停止コマンドなどの重要なメッセージはQoS 1または2を使う価値がありますが、高頻度のテレメトリで多少の欠損が許容されるならQoS 0が効率的です。トピックごとにQoSを切り分けて使うことでパフォーマンスと信頼性のバランスを取れます。また、キープアライブ間隔やクライアントのチューニングによって、切断検知までの時間やネットワーク負荷も左右されます。
- **他プロトコルとの比較効率**
  同等のデータ交換でも、MQTTはHTTPと比べて帯域幅使用量が大幅に少なく、高速なスループットを実現しやすいです。WebSocketも持続的な接続を利用するため性能は近いですが、MQTT特有のトピックルーティングやフレーム最適化、QoSなどのメリットはありません。

結論として、適切なQoS設定や大容量データの扱いへの注意、そして十分なブローカー／クライアントのリソース確保を行えば、MQTTはリアルタイムAIに必要なパフォーマンス要件を満たしやすいといえます。

## AIワークロードにおけるMQTTと他プロトコルの比較

AI／LLM推論と多数のデバイスを連携させる場合、HTTP REST APIやWebSocket、Apache Kafkaなどを使う選択肢もあります。どれにも長所があり、往々にして競合というより補完的に使われることが多いです。

### プロトコル比較表

以下は、AI・IoTワークロードの文脈でのMQTT、HTTP、WebSockets、Kafkaの比較です。

| **プロトコル**   | **通信モデル**                                               | **AI/IoTにおける利点**                                       | **欠点 / 制限**                                              |
| :--------------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| **MQTT**         | ブローカー経由のPub/Sub。イベント駆動で多対多。クライアントは長時間TCP接続を維持。 | オーバーヘッドが非常に小さい。双方向メッセージングが可能。QoSによる信頼性確保。水平スケール容易。送受信を疎結合にでき、リソース制約のあるデバイスや不安定なネットワークに最適。 | MQTTブローカーという追加コンポーネントが必要。大容量ファイル送信には不向き（可能だが非効率）。長期的なストレージやバッチ分析には向かない（短期のメッセージ保持が中心）。 |
| **HTTP**         | リクエスト／レスポンス型のクライアント-サーバー（基本的に1対1）。接続は都度確立（またはHTTP keep-alive）。 | ほぼすべてのLLMプロバイダがHTTP/JSONエンドポイントを提供。オンデマンド問い合わせに最適。HTTPエコシステムをフル活用できる。 | 連続データの送信にはオーバーヘッドが大きい。リアルタイムプッシュは標準でサポートされない。オフライン時のキューイング機能がなく、MQTTのようにQoSが組み込まれていないため、重要データの配信保証を自前実装する必要がある。 |
| **WebSocket**    | TCP上でフルデュプレックスの持続接続。ハンドシェイク後はクライアント⇄サーバーで常時双方向通信。通常1クライアント対1サーバー。 | Webアプリなどのリアルタイム双方向通信に向いている。メッセージ単位のオーバーヘッドがHTTPより小さい。多くのブローカーでMQTT over WebSocketをサポート。 | 純粋なWebSocketにはPub/SubやQoSなどの機能はない。スケールアウトが複雑。セキュリティ面はHTTPに準じる（WSSなど）。ブラウザ制約（CORS等）でクロスドメインIoTはやや面倒。 |
| **Apache Kafka** | 分散イベントストリーミングプラットフォーム。Pub/Sub型だがログストレージを持つ。 | 高スループット・高耐久性。ビッグデータ分析やトレーニングデータ収集に最適。イベントがログに保存されるため、消費者が再生や取りこぼしなく取得可能。パーティション内の順序保証が強力。IoTデータの時系列分析にも有用。 | エッジ/IoTには重量級。プロトコルが複雑で、リソース要件も大きい。データセンターやクラウドでの運用が前提。即時制御や低レイテンシ推論には向かない。運用が複雑。MQTTのようなラストウィルやRetained Messageはない。 |

### どのように使い分けるか

実際には、これらのプロトコルを組み合わせて使うのが一般的です。MQTTやWebSocketはリアルタイムのやり取りを担い（デバイス⇄AIやWeb UI⇄サーバー）、HTTPはAIサービスが外部APIを呼び出す際に利用され、Kafkaはクラウド側で大規模なデータ蓄積やオフライン分析に使われる……といった具合です。
エッジやIoTでAIを運用する文脈では、HTTPよりMQTTの方が効率性が高く、非同期通信が簡単に実現できるというメリットがあります。またWebSocketよりもメッセージング機能が充実しており、Kafkaはクラウド上での大規模分析や再生機能を補完的に担います。

## 課題、制約、そして今後のトレンド

MQTTをAI・LLM用途に活用するメリットは多いものの、課題や制約も存在します。また、それらを解消する新たなトレンドも出始めています。

### 課題・制限

- **AIワークフローとの統合**
  多くのAI/LLMサービスはリクエスト／レスポンス（REST API）の形態に最適化されているため、イベント駆動のMQTT世界との橋渡しが必要になる場合があります。たとえば、クラウドLLM APIを利用するなら、MQTTメッセージを購読してHTTPでLLM APIを呼び出し、結果を再びMQTTで返すような仲介サービスが必要となり、エラー処理などの実装が複雑化します。これはMQTTの問題というより、統合のための“グルーコード”をどう作るかという課題です。現状、多くはカスタム開発で対処されていますが、エコシステムは発展途上です。EMQXプラットフォームはこの5月にリリース予定のData Integration機能で、LLM機能をネイティブにサポートする開発を進めており、IoTデータとLLM推論のよりシームレスな連携を目指しています。
- **データ量とLLMのコンテキスト制限**
  LLMは入力コンテキストサイズに上限があります。工場の膨大なテレメトリをまとめてプロンプトに含めるわけにはいかず、MQTTで入ってくる大量のリアルタイムデータのどれをどのように要約して渡すかは難しい問題です。データが少ないとAIが洞察を得られなかったり、多すぎるとトークン数を超えたり処理が遅くなったりします。将来的にストリーミング対応のAIが発展すれば改善が期待できますが、現状はプロンプトエンジニアリングでうまく絞り込む必要があります。
- **QoSとスケーラビリティのバランス**
  大規模システムでMQTT QoS 2（厳密に1回だけ配信）を常に使うと、パフォーマンスが低下し複雑化も増します。多くのIoT-AIシナリオでは、テレメトリはQoS 0または1で十分であり、クリティカルなメッセージのみQoS 2を使うという運用が一般的です。絶対的にメッセージの重複や欠落を許さない金融取引などではMQTTを主軸にしない場合もあるでしょう。
- **ブローカーが単一点障害になりうる**
  ブローカーがダウンすれば通信が停止します。クラスタリングや冗長化によって対処は可能ですが、設定ミスや設計不足で停止すればシステム全体が影響を受けます。完全に分散型のプロトコル（メッシュネットワークなど）に比べ、ブローカーモデルはわかりやすい反面、中央集権的なリスクがあります。ミッションクリティカルなシステムではフェイルオーバー構成やバックアップの通信手段が必要になる場合もあります。
- **セキュリティ対応によるオーバーヘッド**
  TLSや認証を厳格にすると、リソースの限られたマイコンには負荷が大きくなることがあります（TLSハンドシェイクの計算量など）。セッション再開やTLSオフロード機構を活用したり、大量デバイスの証明書管理を自動化するプラットフォームを導入するなど、運用面での工夫が必要です。十分なセキュリティ対策を取らないと、MQTTの利便性が裏目に出て、不正なデバイスがAIに悪意あるデータを送ったり機密トピックにアクセスしたりするリスクが生じます。
- **相互運用性と標準化**
  MQTT自体はオープン標準ですが、トピック命名規則やペイロード形式は各運用環境によってさまざまです。スマートホームで `home/livingroom/temp` としている場合と、別環境が `house/room1/temperature` などの場合、あらかじめ整合性を取らないとAIやアプリケーションが流用できません。産業IoTでは**Sparkplug**のようにトピック命名やペイロードの標準化を行う仕様がありますが、それ以外の場面ではカスタム実装になることが多く、AI導入時に統一が課題となります。
- **バイナリやリッチデータの扱い**
  MQTTはバイナリペイロードを扱えますが、数MB以上の画像や音声などは非効率です。5MBの画像をMQTTで送ることは不可能ではないものの、転送コストやメモリ負荷が大きく、より適切なストリーミング手段を用いた方が良い場合が多いでしょう。ビデオストリーミングや高周波データはMQTTでの連続配信には向かず、メタデータやイベント通知にとどめることが一般的です。実際、ドローン映像をAI解析するようなケースでは映像自体は別チャネルで送信し、MQTTは制御コマンドやアラート配信に使われるのが現実的です。

### 今後のトレンド

- **エッジAIとMQTT**
  AIをクラウドだけでなくエッジにも配置し、データ発生源に近いところで推論を行う動きが加速しています。遅延やプライバシーの観点でメリットが大きいです。**LLMやMLモデルをゲートウェイやデバイス上で動作**させ、センサートピックを直接購読して推論結果をMQTTでやり取りする形が増えると予想されます。たとえばスマートファクトリーで、専門用語に特化した小型LLMをエッジ上に動かして機械データを購読し、作業員の質問にローカルで回答するといったシナリオです。[AWSのIoTブログ](https://aws.amazon.com/blogs/iot/emerging-architecture-patterns-for-integrating-iot-and-generative-ai-on-aws/#:~:text=Deploying generative AI on IoT,edge hardware limitations%2C energy consumption)も、「Small Language Models（SLM）をエッジに配置してレイテンシとプライバシーを改善する」ケースを想定しており、その際にAWS IoT GreengrassなどのMQTT技術を使う例を挙げています。NVIDIA Jetsonのようなエッジ向け高性能ハードウェアの普及に伴い、エッジAIエージェントがMQTTトピックを介して協調動作するシナリオが増えていくでしょう。
- **AIソフトウェアのイベント駆動アーキテクチャ**
  AIアプリケーション自体がイベント駆動型を採用する流れが出てきています。モノリシックなモデルサーバーではなく、イベントドリブンなマイクロサービス（データ前処理、推論、ポストプロセスなど）をメッセージングで接続する形です。MQTTなどのプロトコルは分散環境でも非常に適しており、**AIネイティブなイベント駆動アーキテクチャ**が広がっていくと考えられます。将来的にはフレームワークやツールがMQTTブローカーをファーストクラス市民として扱い、AIパイプラインを構築できるようになるでしょう。
- **MQTT 5以降の機能拡張**
  MQTT 5.0ではリクエスト／レスポンスの関連付け機能やユーザープロパティ、詳細なエラー報告などが導入され、RPCスタイルのAI問い合わせとの連携がしやすくなりました。将来的にはMQTT上で推論リクエストとレスポンスをやり取りする標準的な方法（相関IDを使うなど）がより一般化する可能性があります。また、[**QUIC上でのMQTT**](https://www.emqx.com/ja/blog/mqtt-over-quic)のように新しいトランスポート層も検討されており、UDPベースのQUICはロスの多いネットワークでの高速接続確立やマルチプレックス性能に優れるため、TCPよりさらに低遅延を実現できるかもしれません。
- **コンテキスト情報の統合**
  LLMがMQTTシステムと連携することで、単なる生データだけでなく、AIエージェント同士がコンテキスト情報をやり取りするようなシナリオが考えられます。たとえばスマートホームや工場内の複数AIエージェントが、それぞれの分析結果や推論内容をMQTTで共有し合う「共通ナレッジバス」として機能する可能性もあります。これはやや先進的なアイデアですが、AIエージェント間での協調が進むにつれ、MQTTを活用したマルチエージェントシステムが登場するかもしれません。

総合すると、IoTとAIがともに進化するにつれてMQTTの役割はますます重要になるでしょう。統合の複雑さやデータ量の管理、セキュリティのスケール対応など課題もありますが、コミュニティやベンダーが積極的に対策を進めており、エッジAIやイベント駆動アーキテクチャなど新たなトレンドがMQTTの適用範囲を広げています。すでに10年以上の歴史でセンサーネットワークからLLM搭載システムへと進化を遂げてきたMQTTは、今後もエッジコンピューティングや5G/6Gの普及、高度なAIモデルの登場に伴って、**AIoT（AI + IoT）の中核**を担う存在として発展を続けるはずです。

## **まとめ**

MQTTは、IoTとAIを結びつける上で極めて有用なテクノロジーであることが実証されています。ビジネス層にとっては、MQTTを導入することでリアルタイムかつ効率的、スケーラブルなデータフロー基盤を得られ、そこに強力なAI・LLMのインサイトを組み合わせることで、操作の即応性向上や新たな知的サービスを創造し、組織全体のデータ活用を最大化できる点が魅力といえます。エンジニアリングチームにとっては、分散システムでのデータ転送という煩雑な部分をMQTTがシンプルにしてくれるため、AI本来の機能開発に注力しやすくなるでしょう。ただし、セキュリティをはじめとする要件を適切に設計し、大規模化への備えを怠らないことが重要です。幸い、MQTTのツール群やベストプラクティスは充実しており、今なお進化し続けています。

今後は、エッジへのAI配置が進み、MQTTのエコシステムとの結合がより強まることが予想されます。また、標準化されたデータスキーマやイベント駆動設計の普及により、LLMなどの高度なAIエージェントがIoT領域に簡単に“プラグイン”できるようになるでしょう。
MQTTが万能というわけではありませんが、**AI対応のIoT（AIoT）の中核を担う要素**であることは確かです。AIを実運用で活用するためには、適時かつ正確に情報を受け渡す“神経系”が必要ですが、まさにMQTTがその役割を担います。
LLMなどのAIモデルが現実世界を理解し、推論し、行動を起こすために必要なシグナルを途切れなく届ける存在。それがMQTTです。AIアーキテクチャにMQTTを取り入れることは、より迅速でスケーラブル、かつ洞察力の高いシステムを目指す大きな一歩となるでしょう。



<section class="promotion">
    <div>
        専門家と話します
    </div>
    <a href="https://www.emqx.com/ja/contact?product=solutions" class="button is-gradient">お問い合わせ →</a>
</section>
