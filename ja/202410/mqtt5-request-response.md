この記事では、[MQTT](https://www.emqx.com/ja/blog/the-easiest-guide-to-getting-started-with-mqtt)の非同期メッセージ配信フレームワーク下での**リクエスト／レスポンス**パターンの実装方法について、MQTT 5.0の新機能を活用しながら詳しく解説します。

> *MQTT 5.0を初めてご利用ですか？ぜひご覧ください*
>
> [MQTT 5.0：7つの新機能と移行チェックリスト](https://www.emqx.com/ja/blog/introduction-to-mqtt-5)

## MQTT 5.0以前のリクエスト／レスポンス

MQTTのパブリッシャー／サブスクライバー機構は、メッセージの送信者と受信者を完全にデカップリングし、メッセージを非同期的に配信することを可能にします。しかし、これには問題もあります。QoS 1およびQoS 2メッセージを使用しても、パブリッシャーはメッセージがサーバーに到達したことを保証できますが、サブスクライバーが最終的にメッセージを受信したかどうかを知ることはできません。リクエストやコマンドを実行する際に、パブリッシャーは相手側の実行結果を知りたい場合があります。

最も直接的な方法は、サブスクライバーがリクエストに対してレスポンスを返すことです。

MQTTでは、これは実装が難しくありません。通信する双方が事前にリクエストトピックとレスポンストピックを交渉し、サブスクライバーがリクエストを受信した後にレスポンストピックにレスポンスを返すだけです。これは、MQTT 5.0以前のクライアントが一般的に採用していた方法でもあります。

このスキームでは、レスポンストピックを事前に決定し、柔軟に変更することができません。異なるリクエスターが複数存在する場合、同じレスポンストピックにサブスクライブする必要があるため、すべてのリクエスターがレスポンスを受け取ることになり、**レスポンスが自分自身に属するかどうかを判断できません**：

![request response before mqtt5](https://assets.emqx.com/images/d3f0f0f49cc4e5911f1b8f61580504a5.jpg)

<center>複数のリクエスターがレスポンスの混乱を引き起こしやすくなります</center>

<br>

この問題を回避する方法はいくつかありますが、ベンダー間で実装が完全に異なる可能性があり、異なるメーカーのデバイスを統合する際のユーザーの難易度と作業負荷が大幅に増加します。

これらの問題を解決するために、MQTT 5.0では**レスポンストピック**、**コリレーションデータ**、**レスポンス情報**などのプロパティが導入され、MQTTにおける**リクエスト／レスポンス**パターンを標準化しました。

## MQTT 5.0のリクエスト／レスポンスはどのように機能するか？

### プロパティ1 - レスポンストピック

MQTT 5.0では、リクエスターがリクエストメッセージに期待するレスポンストピックを指定できます。リクエストメッセージに基づいて適切なアクションを実行した後、レスポンダーはリクエストに含まれるレスポンストピックにレスポンスメッセージを発行します。リクエスターがそのレスポンストピックにサブスクライブしていれば、レスポンスを受け取ることができます。

![response topic](https://assets.emqx.com/images/92889c77ff810e13135d8be208e79ce5.jpg)

リクエスターは、クライアントIDをレスポンストピックの一部として使用することで、異なるリクエスターが意図せず同じレスポンストピックを使用することで発生する競合を効果的に回避できます。

### プロパティ2 - コリレーションデータ

リクエスターは、リクエストにコリレーションデータを含めることもでき、レスポンダーはレスポンスにそのコリレーションデータをそのまま返す必要があります。これにより、リクエスターはレスポンスがどのリクエストに属するかを識別できます。

これにより、レスポンダーがリクエストの順序とは異なる順序でレスポンスを返した場合や、ネットワーク切断によりレスポンス（QoS 0）が失われた場合でも、リクエスターがレスポンスを誤ってリクエストに関連付けることを防止できます。

一方で、リクエスターが複数のレスポンダーとやり取りする必要がある場合（例えば、スマートフォンを介して家庭内のさまざまなスマートデバイスを制御する場合など）、コリレーションデータを使用することで、単一のレスポンストピックにサブスクライブしながら、複数のレスポンダーから非同期的に返されるレスポンスを管理できます。

![correlation data](https://assets.emqx.com/images/4512c244552569dcaca4880db299a665.png)

上記の**リクエスト／レスポンス**プロセスでは、[MQTTブローカー](https://www.emqx.com/ja/blog/the-ultimate-guide-to-mqtt-broker-comparison)はレスポンストピックやコリレーションデータを変更せず、単に転送エージェントとして機能します。

### プロパティ3 - レスポンス情報

セキュリティ上の理由から、MQTTサーバーは通常、クライアントが発行およびサブスクライブできるトピックを制限します。リクエスターはランダムなレスポンストピックを指定できますが、そのトピックにサブスクライブする権限があるかどうかを保証できず、レスポンダーがそのレスポンストピックにメッセージを発行する権限があるかどうかも保証できません。

したがって、MQTT 5.0では**レスポンス情報**プロパティも導入されました。クライアントは、CONNECTパケット内でレスポンス情報の要求識別子を1に設定することで、サーバーにCONNACKパケット内でレスポンス情報を返すよう要求できます。クライアントは、このレスポンス情報の内容をレスポンストピックの特定部分として使用し、サーバーの権限チェックを通過させることができます。

![response information](https://assets.emqx.com/images/f6962b2403339ec5dbade5b6ca2ffc33.png)

MQTTは、この部分の詳細（レスポンス情報の内容形式や、クライアントがレスポンス情報に基づいてレスポンストピックをどのように作成するかなど）をさらに指定していないため、異なるサーバーおよびクライアントの実装によって異なる場合があります。

例えば、サーバーはレスポンス情報「FRONT,mytopic」を使用して、レスポンストピックの特定部分の具体的な内容とその位置を示すことができます。または、事前にクライアントとこの特定部分の使用方法について合意し、レスポンス情報「mytopic」を使用してこの部分の具体的な内容のみを示すこともできます。

スマートホームシナリオを例に取ると、スマートデバイスはユーザー間で共有されることはありません。MQTTサーバーがデバイスが属するユーザーのIDをレスポンス情報として返すようにし、クライアントはこのユーザーIDをレスポンストピックのプレフィックスとして一律に使用することができます。MQTTサーバーは、クライアントのセッションのライフサイクル中にこのユーザーIDで始まるトピックに対する発行およびサブスクライブの権限を確保するだけで済みます。

## MQTTリクエスト／レスポンス使用の提案

以下は、MQTTで**リクエスト／レスポンス**を使用する際の提案です。これらに従うことで、ベストプラクティスを実装するのに役立ちます：

1. MQTTのQoS 1および2はメッセージがサーバーに到達することを保証しますが、メッセージがサブスクライバーに到達したかどうかを確認したい場合は、**リクエスト／レスポンス**パターンを使用できます。
2. リクエストを送信する前にレスポンストピックにサブスクライブして、レスポンスを見逃さないようにします。
3. レスポンストピックに対する発行およびサブスクライブの権限をレスポンダーとリクエスターの両方が持っていることを確認します。レスポンス情報は、権限要件を満たすレスポンストピックを構築するのに役立ちます。
4. 複数のリクエスターが存在する場合、レスポンスの混乱を避けるために異なるレスポンストピックを使用する必要があります。クライアントIDをトピックの一部として使用することが一般的な方法です。
5. 複数のレスポンダーが存在する場合、リクエスターがリクエストにコリレーションデータを設定することで、レスポンスの混乱を避けることが最善です。
6. **リクエスト／レスポンス**とウィルメッセージを連携させることができます。接続時にウィルメッセージのレスポンストピックを設定するだけで、クライアントがオフライン期間中にウィルメッセージが消費されたかどうかを知ることができ、適切な調整を行うことができます。

## デモ

次に、[MQTTX](https://mqttx.app/ja)を使用して、スマートフォンから寝室のライトをリモートで操作し、レスポンスを受け取るシナリオをシミュレートします。

1. MQTTXをインストールして開きます。新しいクライアント接続を作成し、モバイルフォンをシミュレートします。MQTTバージョンを5.0に設定し、**レスポンストピック**として`state/light-in-bedroom/power`にサブスクライブします：

   ![mqttx 01](https://assets.emqx.com/images/0d09b79ac901828f0737f3f3305c9be4.png)

2. スマートライトをシミュレートするために新しいクライアント接続を作成し、リクエストトピック`cmnd/light-in-bedroom/power`にサブスクライブします：

   ![mqttx 02](https://assets.emqx.com/images/27a86381a75f1d68b15ab64e2edc485d.png)

3. リクエストクライアントに戻り、レスポンストピックを指定してリクエストトピック`cmnd/light-in-bedroom/power`にライトをオンにするコマンドを送信します：

   ![mqttx 03](https://assets.emqx.com/images/aaf3322398e3f919d1896bd1726bebeb.png)

4. レスポンスクライアントでは、受信したメッセージがレスポンストピックを含んでいることが確認できます。次に、このレスポンストピックに基づいてライトをオンにする操作を実行し、レスポンストピックを通じて最新のライトの状態を返します：

   ![mqttx 04](https://assets.emqx.com/images/978c9d24fc743c92a1d6cf5a75fff045.png)

5. 最終的に、リクエストクライアントはこのレスポンスを受信し、レスポンスメッセージの内容に基づいてライトが正常にオンになったことを確認できます。

   ![mqttx 05](https://assets.emqx.com/images/4be557386f9385f719f8145ef42b523c.png)

これは非常にシンプルな例ですが、パブリッシャーやレスポンダーの数を増やして、これらの場合にリクエストおよびレスポンストピックをどのように設計するかを体験することもできます。

さらに、**リクエスト／レスポンス**のPythonサンプルコードを[emqx/MQTT-Features-Example](https://github.com/emqx/MQTT-Feature-Examples)で提供していますので、参考にしてください。



<section class="promotion">
    <div>
        専門家と話します
    </div>
    <a href="https://www.emqx.com/ja/contact?product=solutions" class="button is-gradient">お問い合わせ →</a>
</section>
