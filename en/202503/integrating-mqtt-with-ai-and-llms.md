Having explored how MQTT connects IoT data with AI and LLM applications in [the first piece of this series](https://www.emqx.com/en/blog/why-and-how-mqtt-is-used-in-ai-llm-applications), we now focus on the practical aspects of implementation. In this blog, we will delve into critical considerations for deploying MQTT in AI applications, including security, scalability, and performance, along with protocol comparisons, challenges, and future possibilities.

## Security, Scalability, and Performance Considerations

While MQTT offers many benefits, deploying it for AI and LLM inference at scale requires careful attention to security, scalability, and performance:

### Security Considerations

[MQTT](https://www.emqx.com/en/blog/the-easiest-guide-to-getting-started-with-mqtt) was designed for lightweight messaging, but in mission-critical AI applications (e.g. controlling physical devices), security is paramount. Key aspects include:

- **Authentication & Authorization:** Ensuring only authorized clients (devices or AI services) can connect and publish/subscribe to certain topics. MQTT itself is agnostic to auth mechanisms, but brokers implement these. Common approaches are [username/password](https://www.emqx.com/en/blog/securing-mqtt-with-username-and-password-authentication), [TLS client certificates](https://www.emqx.com/en/blog/two-way-tls-ssl-with-emqx-cloud), or [JWT tokens](https://www.emqx.com/en/blog/a-deep-dive-into-token-based-authentication-and-oauth-2-0-in-mqtt) to authenticate devices. Fine-grained **Access Control Lists (ACLs)** define which client can subscribe/publish to which topic (for example, a thermostat device should only publish on home/thermostat/{sensor-id}/temp and not listen to unrelated topics). Robust authN/Z prevents malicious actors from injecting false data or commandeering actuators.
- **Encryption:** MQTT can (and in serious deployments, should) be run over TLS, just like HTTPS, to encrypt data in transit. This prevents eavesdropping or tampering with the IoT data that AI might rely on. Many MQTT brokers enforce TLS on port 8883. For additional security, some applications even encrypt message payloads at the application level (end-to-end encryption) to protect data from broker compromise.
- **Data Integrity & Validation:** AI systems must trust the data they receive. Using MQTT with QoS 1 or 2 can guarantee delivery of messages at least once or exactly once, ensuring data isn’t lost or duplicated in transit due to network issues. However, integrity also means validating that data is well-formed and within expected ranges – to avoid feeding invalid or malicious inputs into an AI model (which could cause unpredictable results). This may involve adding schema validations. [EMQX Smart Data Hub](https://www.emqx.com/en/blog/introducing-emqx-platform-smart-data-hub) provides the build-in **Schema Registry** and **Schema Validation** features for data integrity.
- **Security of the Broker:** The [MQTT broker](https://www.emqx.com/en/blog/the-ultimate-guide-to-mqtt-broker-comparison) is a critical hub – it should be hardened and monitored. Use strong credentials, update broker software to patch vulnerabilities, and consider network segmentation (e.g. brokers behind firewalls or VPNs). Enabling logging and monitoring on the broker helps detect suspicious activity (like an unknown client subscribing to many topics, possibly scraping data). Rate limiting can be used to mitigate brute-force or DDoS attempts at the broker.
- **LLM-specific Security:** When an LLM is in the loop, there are some unique considerations. If prompts or outputs are sent via MQTT, sensitive information could be exposed if topics aren’t secured. Also, one must guard against **prompt-injection** or malicious commands published to the broker that target the LLM’s behavior. For example, an attacker could publish a specially crafted prompt on a topic the LLM service subscribes to, attempting to manipulate its response. Implementing input validation or using LLM guardrails would be prudent in such scenarios.

In summary, securing MQTT involves applying standard IT security principles – confidentiality, integrity, availability – to an IoT context

> *“MQTT security is crucial to ensure the confidentiality, integrity, and availability of data exchanged between devices” -* [7 Essential Things to Know about MQTT Security 2023](https://www.emqx.com/en/blog/essential-things-to-know-about-mqtt-security)

Best practices include robust authentication, encryption (TLS), topic-level authorization, and vigilance against anomalies. When done properly, MQTT can be used in AI systems with high confidence in data security (indeed, industries like automotive and healthcare are using MQTT for sensitive data).

### Scalability Considerations

AI applications, especially in IoT, may need to handle massive scale – from thousands to millions of devices all streaming data. MQTT brokers and infrastructure must be designed to scale accordingly:

- **Broker Throughput and Clustering:** A single MQTT broker can handle a very large number of concurrent clients and messages per second. Benchmark figures show impressive numbers (e.g. EMQX, connecting [**100 million devices concurrently on a cluster**](https://www.emqx.com/en/blog/reaching-100m-mqtt-connections-with-emqx-5-0) in a reliable way). To achieve this, deployments often use broker clusters – multiple broker nodes that share the load (and often share session state). New clients are load-balanced across cluster nodes, and messages can be routed cluster-wide so that subscribers get their data regardless of which node they’re on. This linear scalability is crucial as an IoT-AI system grows – you can add more broker nodes to handle more devices or higher message throughput, maintaining performance.

  ![100 million connections](https://assets.emqx.com/images/9e455a23d7148e0a2a25e41e5e161432.png)

<center>100 million connections</center>

- **Topic Hierarchy and Partitioning:** How you design the MQTT topic hierarchy can impact scalability. Flat or very large fan-in topics (many devices publishing to one topic) can become bottlenecks. It can be better to partition topics (e.g. each device or region with its own branch) so that load is distributed. Some brokers allow partitioning similar to Kafka’s partitions for scaling, but typically MQTT relies on the topic structure and multiple brokers for distribution. Ensuring the AI subscribers are efficiently subscribing (using wildcards where appropriate but not subscribing to enormous catch-all topics unless needed) helps manage the load.

- **Overload, Backpressure, and Offline Handling:** In AI inference scenarios, consider what happens if the AI service cannot keep up with the incoming message volume. Although MQTT’s QoS is primarily about message delivery between device and broker, once the broker delivers messages to the AI subscriber, the backlog can shift to the LLM processing layer if it cannot process messages quickly enough. In that case, local or downstream queues may accumulate an ever-growing number of unprocessed messages, risking data loss if the queue capacity is exceeded.

  Additionally, when many devices go offline and then reconnect en masse, they can create a sudden surge (“thundering herd”) of messages that overwhelms the AI service. To manage these spikes, one needs sufficient buffering or a stream-processing framework (e.g., Apache Flink or Kafka Streams) to smooth or distribute the load. Implementing backpressure or admission control at the AI service side can help gracefully handle temporary overload, preventing dropped messages and preserving overall system stability—though it adds complexity.

- **Bridging to Big Data Systems:** Often, IoT deployments will use MQTT to get data off devices and then feed it into a data pipeline (cloud databases, Apache Kafka, etc.) for aggregation, training AI models, and long-term analytics. In fact, MQTT and Kafka are frequently used together as complementary technologies. MQTT handles the device connectivity in real-time; Kafka handles scalable storage and processing downstream. Bridging from MQTT to Kafka (via connector or broker extension) can help scale the system for big-data AI workloads.

- **Edge and Cloud Distribution:** For very large scale, a hierarchical deployment can be effective: **edge brokers** collect data on-site (e.g. one per factory or one per vehicle/local network) and perform local inference or filtering, then bridge important data up to a central/cloud MQTT broker for global AI analysis. This limits bandwidth usage and scales logically. Each edge broker handles a slice of the load, and the cloud broker aggregates higher-level insights. This pattern is seen in automotive (each car has an internal broker for subsystems and connects to the cloud) and in industrial setups (site-level MQTT brokers feeding corporate-level MQTT).

In short, MQTT is highly scalable, but architects must design the system (brokers, topics, clustering) to meet the volume. Fortunately, enterprise MQTT platforms, such as EMQX Platform, and cloud IoT services provide the needed scalability out-of-the-box for most use cases – enabling growth from a pilot with 100 devices to a deployment with 100M+ devices without a redesign.

### Performance Considerations

Performance in MQTT-based AI systems can be viewed in terms of **latency, throughput, and resource usage**:

- **Latency:** MQTT is designed for low latency delivery – after the initial TCP connection and handshake, data packets are extremely small. Messages can often be delivered from device to broker to subscriber in a few tens of milliseconds (network permitting). This is far faster than an HTTP cycle which might take hundreds of ms due to TCP/TLS handshakes and request overhead. For AI inference, this low latency means fresher data and quicker responses. For instance, if using an LLM to respond to a voice command, MQTT could shave perceptible time off the round-trip vs. a REST API call. However, total inference time also includes the AI processing, which might be more significant (e.g. a large LLM might take seconds to generate an answer). Still, minimizing transport latency is beneficial, especially when chaining multiple services. One thing to monitor is the latency under load – a broker should be sized such that it doesn’t become a bottleneck with many messages (clustering and load balancing help here). In practice, MQTT brokers are very efficient (written in languages like Erlang or C++ with async networking) and can maintain low latency at high throughput, but testing your specific workload is advised.
- **Throughput and Message Size:** MQTT works best with lots of small messages (the typical IoT scenario). If your AI application needs to send large payloads (like an image or a large prompt) through MQTT, it can do so, but be aware of limits. MQTT 5 supports payloads up to huge sizes (256MB), but many brokers set lower size limits (e.g. 1MB) to avoid memory issues. Large messages may need to be chunked or sent out-of-band (e.g. put a file in cloud storage and send a reference over MQTT). For LLM inference, textual prompts and responses generally fit comfortably in MQTT messages, but something like a model checkpoint update would be too large – in automotive, sending an entire ML model to a car might use a specialized update service rather than raw MQTT. Throughput-wise, modern brokers can process hundreds of thousands of messages per second. If the AI system subscribes to a high-frequency topic (say 10,000 sensor readings per second), ensure the subscriber and network can handle it. In some cases, downsampling or aggregating at the edge (using an MQTT client or edge analytics) can significantly reduce message rate with minimal loss of fidelity for the AI.
- **QoS Trade-offs:** MQTT QoS 0 is fastest (fire-and-forget, no acknowledgments) but can drop messages occasionally. QoS 1 and 2 add overhead (acknowledgments, potential retries, or duplicate handling) which can impact performance slightly. For critical data that the AI must receive (e.g. an emergency shutdown command or a critical alert to an operator), QoS 1 or 2 is worth the slight performance cost to ensure delivery. For high-frequency telemetry where occasional loss is tolerable, QoS 0 keeps throughput high. Balancing QoS per topic is a way to optimize performance. Similarly, keep-alive intervals and client tuning can affect how quickly disconnections are detected (important for failover but too frequent pings can add network load).
- **Comparative Efficiency:** Compared to other protocols, MQTT is generally more efficient for IoT-scale messaging. For instance, in MQTT vs HTTP tests, MQTT often uses dramatically less bandwidth for the same data exchange and supports faster throughput. WebSockets are closer in performance to MQTT since they also use a persistent connection, but a raw WebSocket lacks MQTT’s optimized frame format and features like topic routing.

In summary, MQTT can meet the performance needs of real-time AI applications, delivering data with low latency and minimal overhead. But architects should design thoughtfully: use appropriate QoS, avoid unnecessarily huge messages, and ensure the broker and clients are provisioned to handle the expected message rates. By following best practices (and leveraging the extensive performance tuning guides available for MQTT), one can build an AI+IoT system that is both responsive and robust under load.

## MQTT vs. Other Protocols for AI Workloads

When integrating AI/LLM inference with distributed devices, one may wonder how MQTT compares to alternatives like HTTP REST APIs, WebSocket connections, or Apache Kafka. Each has its merits and ideal use cases, often they are complementary rather than strictly competing.

### Protocol Comparison

Here we provide a comparison of MQTT with HTTP, WebSockets, and Kafka in the context of AI and IoT workloads:

| **Protocol**     | **Communication Model**                                      | **Pros for AI/IoT**                                          | **Cons / Limitations**                                       |
| :--------------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| **MQTT**         | Pub/Sub via broker; event-driven, many-to-many. Clients maintain long-lived TCP connections to brokers. | Very low overheadBi-directional messagingBuilt-in QoS levels ensure reliable deliveryHorizontal scalingDecouples senders and receiversDesigned for constrained devices and spotty networks | Requires an MQTT broker, an extra component to manageOptimized for small messages; large file transfers are possible but inefficientMessage retention is short-term, not intended for long-term storage or batch analytics |
| **HTTP**         | Request-response, client-server (typically one-to-one). Each request is a separate connection (or uses HTTP keep-alive pooling). | Ubiquitous and simple: almost all  LLM providers offer HTTP/JSON endpoints.Good for on-demand queriesLeverages the whole HTTP ecosystem | High overhead for continuous dataNot real-time push by defaultNo built-in messaging features: HTTP won’t queue messages if a target is offline. For mission-critical data, a lot of custom logic would be needed to match MQTT QoS features. |
| **WebSocket**    | Full-duplex persistent socket over TCP. Allows continuous bi-directional communication after handshake. Typically one client to one server connection. | Enables real-time two-way communication in web apps and beyond.Lower overhead per message than HTTPFairly simple to use with standard web tech.Can be used as a transport for MQTT itself (many brokers allow MQTT over WebSocket) | WebSocket by itself is just a pipe; no built-in pub/sub or routing.Lacks rich QoS.Scaling WebSocket servers to many clients can be complex.Security considerations: Similar to HTTP (use WSS for encryption). But one subtlety – browsers allow WebSocket only to the domains permitted by CORS, etc., so cross-domain IoT scenarios may face issues unless configured. |
| **Apache Kafka** | Distributed event streaming platform. Pub/Sub with persistent log storage. | High throughput & durability: Great for big data pipelines, and training data collection.Consumers can replay or catch up on missed data since events are stored.Scales horizontally by design.Strong ordering guarantees within a partition – useful if sequence of events matters to the AI (e.g. time series analysis). MQTT has ordering per client connection but not a global log like Kafka’s. | Heavyweight for edge/IoT: Kafka is not designed for small devices; it has a much more complex protocol and requires significant resources.It’s typically deployed in data centers or cloud, not on edge devices.Higher latency for immediate command/control: Kafka often introduces a bit more latency because data is written to disk and possibly replicated. For real-time control or quick inference triggers, it’s slower than in-memory MQTT delivery.Operational complexity: Managing a Kafka cluster is non-trivial, whereas MQTT brokers are simpler to deploy. Kafka shines for analytics but is overkill for straightforward device-to-AI messaging.Lacks built-in concept of last-will or retained messages that are tailored for device sessions. |

### When to Use What?

In practice, these protocols are often used together. MQTT and WebSockets can handle real-time interactions (MQTT for device ↔ AI messaging; WebSocket perhaps for web UI ↔ server streaming). HTTP might be used by the AI service to call external APIs (for example, the LLM service itself might be an HTTP API like OpenAI’s). Kafka might ingest the firehose of data for offline processing, model training, or compliance logging. It’s not necessarily an either/or choice but picking the right tool for each link in the chain. That said, if we focus on deploying AI at the edge or in IoT scenarios: MQTT usually outperforms HTTP in efficiency and simplicity of async communication, and it provides richer messaging semantics than raw WebSockets. Meanwhile, Kafka often complements MQTT by taking over once data reaches the cloud for large-scale aggregation.

Each protocol has its niche, and MQTT’s niche is squarely the space where **resource-constrained devices or applications need a speedy, scalable, and reliable messaging fabric** to feed AI systems.

## Challenges, Limitations, and Future Trends

While using MQTT for AI and LLM applications offers many advantages, there are also challenges and limitations to acknowledge, as well as emerging trends that address them:

### Challenges & Limitations

- **Integrating with AI Workflows:** One challenge is that many AI/LLM services are inherently designed around request-response (e.g. REST APIs). Bridging an event-driven MQTT world with a synchronous AI API world may require intermediary components. For instance, if using a cloud LLM API, you might run a service that subscribes to MQTT messages, then calls the LLM API over HTTP, and then publishes the result via MQTT. This adds complexity in design and error handling (two systems, MQTT and HTTP, need to work in tandem). It’s not a fundamental flaw of MQTT, but integrators must build these “glue” components, which require careful coding. Tools and middleware to more seamlessly connect MQTT to AI inference engines are still evolving. The good news is that the EMQX Platform is actively developing built-in LLM capabilities within its Data Integration feature, planned for release in May, to help unify IoT data streams with LLM inference more seamlessly.
- **Data Volume and Context Limitation:** LLMs have context length limits. In scenarios like feeding an LLM a snapshot of an entire factory’s telemetry (as context for a question), there is a practical limit to how much data can be included in the prompt. MQTT can deliver a deluge of real-time data, but the AI might not consume it raw. There’s a need to aggregate or summarize IoT data for LLM consumption. Designing these summaries or deciding which data to include is a challenge – too little data and the AI may lack insight; too much and you overflow token limits or slow down inference. Future AI systems might handle streaming inputs more gracefully, but current LLMs require careful prompt engineering when using MQTT-fed data.
- **Quality of Service vs. Scalability:** Using MQTT QoS 2 (exactly once delivery) everywhere in a large system can hurt performance and increase complexity. Most IoT AI scenarios settle for QoS 0 or 1 for telemetry, and perhaps QoS 2 for critical messages. This is generally fine, but for use cases that truly need absolute certainty of message delivery and order (e.g. financial transaction processing, which is not typical IoT), MQTT might not be the ideal sole solution. That said, in industrial and vehicle settings, QoS1 is usually sufficient to ensure actions occur, with idempotent handling of any duplicates.
- **Broker as Single Point**: The broker must be reliable – if it goes down, communication stops. Clustering and redundancy are the answers, but misconfiguration can lead to downtime. Compared to a fully distributed peer-to-peer approach (like some mesh networks or decentralized protocols), MQTT’s broker centrality is both a strength (simplicity) and a potential weakness (central point to defend and scale). In mission-critical systems, you need failover brokers, backup routes (some systems fail over to a secondary communication method if MQTT fails, for example).
- **Security Overheads:** Tightening security (TLS, auth) is necessary but does impose overhead on constrained devices and networks. For example, performing TLS handshakes can be expensive for small microcontrollers. Session resumption and TLS offloading can help. Also, managing credentials for potentially thousands or millions of IoT devices (certificate provisioning, rotation, etc.) is non-trivial. Platforms exist to handle this at scale, but an organization must plan for secure onboarding of devices. Without good security hygiene, the very connectivity MQTT provides could be abused (e.g. a compromised device publishing bad data into the AI stream or subscribing to sensitive info).
- **Interoperability and Standards:** While MQTT is an open standard, different deployments might use different topic conventions or payload formats, making interoperability tricky. For example, one smart home might label a topic home/livingroom/temp and another house/room1/temperature. If you drop a pre-trained AI agent into these environments, it would need adaptation. Efforts like the **Sparkplug** specification (which standardizes MQTT topic namespace and payload for industrial devices) aim to solve this in the IIoT space, making it easier for applications (including AI) to plug and play. Without such standards, a lot of integration effort is custom.
- **Handling Binary or Rich Data:** MQTT can carry binary payloads (like images or audio snippets for AI to analyze), but large binary data isn’t MQTT’s forte. Transmitting a 5 MB image via MQTT is possible but not efficient; specialized protocols or direct streaming (or simply sending a URL pointer) might be better. If an AI needs to analyze images from cameras, typically one would send metadata via MQTT and the image via a more suitable channel. Similarly, real-time video or high-frequency signal data might be left to other streaming protocols. MQTT excels at event messages (which can include brief encoded data) rather than continuous high-bandwidth streams. This is a limitation to keep in mind: for AI dealing with video (e.g. a drone video feed to an AI), MQTT wouldn’t carry the raw video – though it might send control commands or alerts about that video.

### Future Trends

- **Edge AI and MQTT:** A clear trend is pushing AI capabilities to the edge, closer to where data is produced, to reduce latency and preserve privacy. We will see more **LLMs and ML models running on IoT gateways or even on devices**, subscribing directly to sensor topics and publishing results or actions. MQTT will be the glue for these on-device models to talk to each other and to the cloud. For example, a smart factory might have an edge box running a smaller version of an LLM (fine-tuned on factory terminology) that listens to machine MQTT topics and can answer workers’ questions locally without cloud connectivity. [AWS’s IoT blog](https://aws.amazon.com/blogs/iot/emerging-architecture-patterns-for-integrating-iot-and-generative-ai-on-aws/#:~:text=Deploying generative AI on IoT,edge hardware limitations%2C energy consumption) notes that *“Small Language Models (SLMs) at the IoT edge offer reduced latency, privacy and offline functionality”*, and MQTT (via AWS IoT Greengrass, for instance) is used to feed those edge-deployed models and collect their outputs. As hardware like NVIDIA Jetsons becomes more capable, expect MQTT to facilitate swarms of edge AI agents collaborating (think multiple machines each with an AI agent, communicating insights and coordinating via MQTT topics).
- **Event-Driven Architectures in AI Software:** AI applications themselves are starting to embrace event-driven patterns for better scalability. Instead of a monolithic model server, future AI systems might break into event-driven microservices (one service does data prep, one does inference, one does post-processing) all linked by messaging. MQTT and similar protocols could be the backbone of such architectures, especially in distributed environments. The concept of **AI-native, event-driven architecture** is gaining traction. This means more frameworks and tooling may natively support MQTT or other brokers as first-class citizens for building AI pipelines (beyond just IoT).
- **Quality Improvements – MQTT 5 and beyond:** MQTT 5.0 introduced features like request-response pairing, user properties, and enhanced error reporting, which can improve integration with RPC-style AI queries and add metadata for tracing. Future versions or extensions might further optimize MQTT for AI use – for instance, standardizing how to send an inference request and receive a response over MQTT (some patterns already use correlation IDs). Also, new transports like [**MQTT over QUIC** ](https://www.emqx.com/en/blog/mqtt-over-quic)(leveraging UDP-based QUIC protocol) are emerging, which could reduce handshake latency and improve performance over lossy networks (QUIC can outperform TCP in certain scenarios). QUIC may also enable better multiplexing – allowing a single device connection to handle many topic streams more robustly. Such improvements will make MQTT even more suited for the fast-paced, interactive needs of AI applications.
- **Integration of Contextual Knowledge:** As LLMs are deployed alongside MQTT systems, we might see MQTT topics carrying not just raw data but contextual information that AI agents share with each other. For example, multiple AI agents (as in a multi-agent system in a smart home or factory) might use MQTT to broadcast their beliefs or conclusions: one agent publishes a summary of current environment state that another agent (LLM) subscribes to for context. This is somewhat speculative, but effectively using MQTT as a common blackboard or knowledge bus for AI agents is an interesting direction.

In conclusion, MQTT’s role in AI and LLM applications is set to grow as both IoT and AI trends advance. The challenges (integration complexity, data volume management, security scaling) are being actively addressed by the community and vendors, while future trends point to even tighter coupling of AI with event-driven IoT data. MQTT’s lightweight, flexible nature positions it well to adapt – it has already evolved over a decade to handle new use cases (from early sensor networks to today’s LLM-powered systems). With the rise of edge computing, ubiquitous connectivity (5G/6G), and ever more powerful AI, MQTT will likely remain a critical component, enabling AI systems to be deeply and pervasively connected to the world of devices and sensors. The journey is just beginning, but MQTT’s proven capabilities and ongoing enhancements mean it will continue to be a backbone of AIoT (AI + IoT) innovation in the years ahead.

## **Conclusion**

MQTT has proven itself as an invaluable technology at the intersection of IoT and AI. For decision-makers, the key takeaway is that MQTT enables real-time, efficient, and scalable data flow – a foundation upon which powerful AI and LLM-driven insights can be built. This means more responsive operations, new intelligent services, and the ability to leverage organizational data to its fullest, from the factory floor to the connected car to the smart home. Engineering teams, meanwhile, gain a flexible architecture that decouples components and simplifies the plumbing of distributed systems, allowing them to focus on developing AI functionality rather than solving data transport issues.  Adopting MQTT in AI applications does come with challenges – security must be architected in from day one, and systems must be designed for scale – but the tools and best practices are mature and continually improving. Looking forward, the trend is toward even greater integration: edge-deployed AI models communicating over MQTT, standardized data schemas enabling plug-and-play AI agents, and event-driven designs becoming the norm for AI systems. By staying abreast of these trends, organizations can future-proof their IoT and AI strategy.

MQTT is not a silver bullet for every scenario, but as this study shows, it has a well-earned role as a critical enabler in AI-enabled IoT (“AIoT”) systems. It empowers the timely flow of information that fuels intelligent decisions.

In summary, **MQTT helps bridge the gap between the physical world of devices and the digital intelligence of AI**. It provides the nervous system for AI applications – carrying signals reliably and swiftly – so that LLMs and other models can sense, reason, and act in our connected environment. Embracing MQTT in your AI architecture is a step toward more responsive, scalable, and insightful systems.



<section class="promotion">
    <div>
        Talk to an Expert
    </div>
    <a href="https://www.emqx.com/en/contact?product=solutions" class="button is-gradient">Contact Us →</a>
</section>
